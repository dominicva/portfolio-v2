---
title: Getting Started with TypeScript in React
author: 'Dominic van Almsick'
date: '2023-09-14'
---

## ⚠️ this article is a work in progress

```tsx
function BlogPost({ title }: { title: string }) {
  return <h1>{title}</h1>;
}

<BlogPost title="Coming soon..." />;
```

## Introduction

We cover the essentials you need to start using TypeScript effectively with React.
This is not a comprehensive guide, and in most (surely all) cases, the [TypeScript docs](https://www.typescriptlang.org/docs/) provide better and more in-depth explanations.

The goal is to get you using TypeScript in your React projects as painlessly as possible.

### What is TypeScript?

TypeScript is a [superset](https://www.cuemath.com/algebra/superset/) of JavaScript. The implication is that any valid JavaScript is valid
TypeScript.

<figure>
  <figcaption className="mb-2">Venn diagram of a superset</figcaption>
  <Image
    src="/assets/ts-js-superset.svg"
    alt="TypeScript superset of JavaScript"
    width={260}
    height={260}
    className="mx-auto"
  />
</figure>

TypeScript is JavaScript **_plus_** the ability to specify types for variables,
function parameters, and more. To quote the TypeScript docs:

> JavaScript provides language primitives like string and number, but it doesn’t check that you’ve consistently assigned these. TypeScript does.

When I first came across TypeScript, I was confused about its exact relationship to JavaScript. Is it a completely separate programming language?
Does it have its own runtime? If you're similarly unsure, the following points might shed some light:

1. TypeScript is a [**static**](https://en.wikipedia.org/wiki/Static_program_analysis) _analysis tool_, which means that it runs _before_ your code.
2. The analysis results in warnings in your IDE or terminal if types in the program are incorrect.
3. Before execution, TypeScript is [**transpiled**](https://hashnode.com/post/compiling-vs-transpiling-cl0z2hugi0cjhj6nv6pp6a1j3) into JavaScript.
4. Since your code is just JavaScript once it runs, TypeScript has no impact on the runtime behaviour of your code. It will not cause more or different errors
   to be thrown. It only _warns_ you about potential errors while you are authoring your code.

## Setting up your development environment

### Vite

We are going to use [Vite](https://vitejs.dev/) as our build tool. It's fast, and supports TypeScript out-of-the-box.

To generate a TypeScript + React template run the following command in your terminal:

```sh
npm create vite@latest -- --template react-ts
```

Note that this doesn't download the required node modules. You will need to `cd` into your project directory and `npm install` before trying to start your dev server.

## The basics

### Typing variables

Let's take the simplest case. We have a variable `month`, to which we want to assign the appropriate integer value
for a given month. E.g. `9` for September.

```ts
let month = 9; // September
```

We can imagine that another developer, or our future selves, might be tempted to re-assign this variable like so

```ts
month = 'October';
```

If we intended for `month` to be used in a mathematical operation, we've now got a bug. For example, if we increment month:

```ts
month++; // month is now NaN
Number.isNaN(month) === true; // yep
```

This is legal JavaScript; we'll get no clues as to which code introduced the bug.
We have to execute code in our heads until we identify where we went wrong. JavaScript alone
doesn't **_surface_** the source of the problem.

TypeScript's purpose is to catch bugs like these during the code authoring process, reducing time and cognitive
load spent on debugging,

Let's re-introduce our `month` variable with TypeScript specific syntax:

```ts
let month: number = 9;
month = 'October';
```

Adding `: number` to the left of the assignment operator explicitly tells TypeScript that `month` should be a number.
When we then try to assign a string to `month` we will immediately get a warning in our IDE. You can experiment with this example
in the [TypeScript playground](https://www.typescriptlang.org/play?#code/PTAEBEFcFNQFwPagORwJ4AdYEsB2AzaAJ2lwGNpkAaUAd1gEMy5IGAbNtUAEwV1VC5o0bqAAqAZQC0AZyxls+bGVAy0uOAwAeofAiIAoEPAAW2GaGhaGAWwxtoAOnETQeQkQtwTsdFlAARgwyIqB8pji42HDY7KDBMtgA5rg2pHAGDnCgNnzeoAC8oACcANwGuRomhSgA8swIAcTI5ZXeANTt5WR8MggOjmwISQAUAHKQNk1EjuZjDGMjbSYAlIUFRXBEMCvlRmAAkvh0sLQMGqGIgbBW9srRoCPRyBYkPTZpuNyhaAiQPHwBLxTOY3LhQL9IERQD1vit9qAsjk8iYAFyCSbTGplBHLGrIeqIaYtIA).

For this example, we didn't need to add extra syntax to get the benefits of type checking.
Whenever possible, TypeScript gets out of our way by using what is called **_type inference_**, inferring the type from the initial assignment.
Best-practice is to avoid adding type annotations when inference is straightforward.

### Getting interesting with objects

As we saw above, TypeScript has no trouble inferring types for simple variables without our help. However, in JavaScript we spend much of our time
working with objects.

We usually have a specific _interface_ in mind for objects we create, even if we are not explicit about it. What properties should the object have? What types are
their values? What operations are permitted on them? Take the following objects, `user1` and `user2`:

```ts
const user1 = {
  name: 'Dom',
  isAdmin: true,
  greeting: 'hello!',
  birthday: 694224000000,
};

const user2 = {
  name: 'Mick',
  greeting(message) {
    console.log(`Hi, ${message}`);
  },
  birthday: '1999-02-04',
};
```

Now reflect on what the following lines of code evaluate to. Which ones crash our program?
Which won't? Are these helpful outcomes?

```ts
user1.isAdmin; // true
user2.isAdmin; // undefined
user1.isAdmin(); // TypeError: user1.isAdmin is not a function

user1.greeting; // 'hello!'
user2.greeting; // f greeting()

user1.birthday - user2.birthday; // NaN
```

- **`user2.isAdmin`:** accessing properties that don't exist is legal JavaScript. You get `undefined`.
  Have we forgotten to assign a value? Is the value intentionally undefined? It seems harmless, but what
  if you're passing this data to a database? What type of data does the `isAdmin` column expect?
  Getting this wrong _will_ cause bugs.

- **`user2.isAdmin()`:** it would be reasonable if `.isAdmin()` were a method, particularly if it involves reading
  from a database or user session. The error message is descriptive, making it easier to identify the source of the issue. Nevertheless,
  it would be nice to avoid mistakes like this altogether.

- **`user2.greeting`:** we get a reference to the `.greeting()` method. Let's say we tried this:

  ```ts
  // assuming this exists on our web page
  const h2 = document.querySelector('h2');

  if (user2.greeting) {
    h2.textContent = greeting;
  } else {
    h2.textContent = 'Hi there!';
  }
  ```

  Now we're displaying a function signature in our UI! I actually saw this happen on a payment confirmation page recently.

- **`user1.birthday - user2.birthday`:** calculating the time between dates is a common
  task. Without knowing their types we have to search our code for the source of `NaN`.

### Specifying types for the user object

Here is the syntax for declaring a custom type and declaring that an object instance should conform to it:

```ts
type UserProps = {
  name: string;
  isAdmin: boolean;
  greeting: string;
  birthday: number;
};

const user1: UserProps = {
  name: 'Dom',
  isAdmin: true,
  greeting: 'hello!',
  birthday: 694224000000,
};
```

You can experiment with this example in the [TypeScript playground](https://www.typescriptlang.org/play?#code/PTAEBMFMGMBsEMBOlT1NArgZwC4HsBbUHATwAdIAoUi0AVS0kQAVE8ytQBeUAb0tCgAdvAKQAXKFyIAlkIDmAbgGgZWAILgCcyQCM8eWJHhDlg+ckg458ydJtnQumYhwALcPBKShGArqZlAF9lShAIGHhYZFR0PCFcExxiN3hkrDc8DFhwOKEAMzxEInx6RhY2DkpoeNxQbCYARkkGJlZ2Th5+QRExSQAiABFCfoAaFTVNbSFJHEQMSHHzS2sFAbdIWFg8AEIxlWdXDy9JADYATgAWACZry4AGR6fxkMowsBNQSABHDBkANyikCE6RIIPgAA8UmkpBRoDJ8jJIJx3CgaCg5LA5FRwog0htENChKAAO4ydyxRhkJBpNHkFBQOA06zxaq1ZINRDXSTdYSiCRSOYOCYaLQ6JwGIwmRwWSBWGx2IUKRyHdyebzCPwBRDBbh8FS9AVDEZLVSi6azeaLFSy+VrUD9DZbXb7QSq44ai43O5PZ6UV5AA).
The syntax looks a lot like a regular JavaScript object, except types take the place of values.
Note the semi-colons separating properties. This is common practice, but commas are also valid.

**The workflow of declaring a custom type and specifying that a variable should conform to it
is exactly how we will type component props in React.**

---

- include demo of array typing, mention any, type inference
- typing function parameters
- contextual typing example with .map - if array element types are known, map doesn&apos;t need to be told
- introduce type and interface including differences / rule of thumb, include optional properties

## Refactor component from JS to TS

- live code refactoring a component to TS

## Some exercises for you to try

1. component refactoring exercise
2. typing children. intro React.PropsWithChildren
3. form submit including types of state and event handlers
4. fetch array of items from API, use TS to specify shape of item objects
5. diving deeper: union and intersection

## Suggested next steps

- unions
- intersections
- generics
